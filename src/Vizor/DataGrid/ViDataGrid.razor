@typeparam TItem

@implements IViDataGrid<TItem>
@inherits ViComponentBase

<!-- TODO: see https://preview.tabler.io/tables.html : table-striped -->
<!-- TODO: -->

<CascadingValue IsFixed="true" Value="this" Name="IViDataGrid">
	@ChildContent
</CascadingValue>

<div class="vidatagrid @CssClass" @attributes="@AdditionalAttributes">
	<div class="card">
		@if (Title != null)
		{
			<div class="card-header">
				<h3 class="card-title">@Title</h3>
			</div>
		}

		@if (ShowSearch)
		{
			<div class="card-body border-bottom py-3">
				<div class="d-flex">
					<!-- TODO: search, optional elements -->
				</div>
			</div>
		}

		<div class="table-responsive">
			@if (isLoading)
			{
				<div class="loaderoverlay"></div>
			}

			<table class="table card-table table-vcenter text-nowrap datatable">
				<thead>
					<tr>
						@foreach (var col in columns)
						{
							if (!col.IsVisible)
								continue;

							if (col.IsSortable)
							{
								<th><button class="table-sort">@col.Name</button></th>
							}
							else
							{
								<th>@col.Name</th>
							}
							<!-- TODO: asc desc class-->
						}
					</tr>
				</thead>

				<!-- TODO: see https://preview.tabler.io/card-actions.html# for actions like refresh, ... to show/hide columns, ... -->

				<tbody class="table-tbody">
					@if (dataSource == null || itemCount == 0)
					{
						<div class="empty">
							<div class="empty-img">
								<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-list-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
									<path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
									<circle cx="15" cy="15" r="4"></circle>
									<path d="M18.5 18.5l2.5 2.5"></path>
									<path d="M4 6h16"></path>
									<path d="M4 12h4"></path>
									<path d="M4 18h4"></path>
								</svg>
							</div>
							<p class="empty-title">No results found</p>
							<p class="empty-subtitle text-muted">Try adjusting your search or filter to find what you're looking for.</p>
						</div>
					}
					else
					{
						var index = currentPageIndex * PageSize;
						@foreach (var item in items)
						{
							<tr @key="index" class="@RowCssClass">
								@foreach (var col in columns)
								{
									if (!col.IsVisible)
										continue;

									@col.Render(item)
									;
								}
							</tr>

							++index;
						}
						<!--
						<Virtualize Items="@items" Context="item" TItem="TItem">
						</Virtualize>
						-->
					}
				</tbody>
			</table>
		</div>


		<div class="card-footer d-flex align-items-center">
			@if (dataSource != null)
			{
				@if (UsePagination)
				{
					if (itemCount > 0)
					{
						<p class="m-0 text-muted">Showing <span>@((currentPageIndex * PageSize) + 1)</span> to <span>@((currentPageIndex * PageSize) + PageSize)</span> of <span>@itemCount</span> entries</p>
					}
					else
					{
						<p class="m-0 text-muted">Showing 0 entries</p>
					}

					<ul class="pagination m-0 ms-auto">
						<li class="page-item @(CanNavigatePrevious ? "" : "disabled")">
							<button class="page-link" @onclick="PreviousPageAsync" tabindex="-1" aria-disabled="@(CanNavigatePrevious ? null : "true")">
								<svg xmlns="http://www.w3.org/2000/svg" class="icon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><polyline points="15 6 9 12 15 18"></polyline></svg>
								prev
							</button>
						</li>

						@{
							var start = PaginationStartIndex;
							var end = PaginationEndIndex;

							for (int i = start; i <= end; ++i)
							{
								int index = i;
								<li class="page-item @(i == currentPageIndex ? "active" : "")"><button class="page-link" @onclick="() => NavigateToPageAsync(index)">@(i + 1)</button></li>
							}

							if (end < maxPageIndex)
							{
								<li class="page-item"><button class="page-link">...</button></li>
								<li class="page-item"><button class="page-link" @onclick="() => NavigateToPageAsync(maxPageIndex)">@(maxPageIndex + 1)</button></li>
							}
						}

						<li class="page-item @(CanNavigateNext ? "" : "disabled")">
							<button class="page-link" @onclick="NextPageAsync" aria-disabled="@(CanNavigateNext ? null : "true")">
								next
								<svg xmlns="http://www.w3.org/2000/svg" class="icon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><polyline points="9 6 15 12 9 18"></polyline></svg>
							</button>
						</li>
					</ul>
				}
				else
				{
					<p class="m-0 text-muted">Showing <span>@itemCount</span> entries</p>
				}
			}
		</div>

	</div>
</div>


@code {

	private List<IViDataGridColumn<TItem>> columns = new();

	private bool isLoading = true;
	private int currentPageIndex = 0;
	private int maxPageIndex = 0;

	private int itemCount = -1;
	private ICollection<TItem> items = new List<TItem>(0);
	private GridDataSource<TItem>? dataSource;

	[Parameter, EditorRequired]
	public object? DataSource { get; set; }

	[Parameter]
	public RenderFragment? ChildContent { get; set; }

	[Parameter]
	public string? Title { get; set; }

	[Parameter]
	public bool UsePagination { get; set; } = true;

	[Parameter]
	public bool ShowSearch { get; set; }

	[Parameter]
	public int PageSize { get; set; } = 50;

	[Parameter]
	public int[] PageSizes { get; set; } = new[] { 10, 25, 50, 100 };

	[Parameter]
	public string? RowCssClass { get; set; }

	protected override async Task OnParametersSetAsync()
	{
		await ReloadData();
	}

	public void AddColumn(IViDataGridColumn<TItem> column)
	{
		this.columns.Add(column);
		StateHasChanged();
	}

	public async Task ReloadData()
	{
		if (dataSource == null || dataSource.DataSource != DataSource)
		{
			dataSource = new GridDataSource<TItem>(DataSource);
		}

		isLoading = true;
		//await InvokeAsync(StateHasChanged);

		if (itemCount < 0)
			itemCount = await dataSource.Count();

		if (UsePagination)
		{
			int count = PageSize;
			if ((currentPageIndex * PageSize) + PageSize > itemCount)
				count = itemCount - (currentPageIndex * PageSize);

			items = await dataSource.LoadDataAsync(currentPageIndex * PageSize, count);
			maxPageIndex = (int)Math.Floor((double)itemCount / PageSize) - 1;
		}
		else
		{
			items = await dataSource.LoadDataAsync(0, itemCount);
			maxPageIndex = 0;
		}

		isLoading = false;
		//await InvokeAsync(StateHasChanged);
	}

	private bool CanNavigatePrevious => currentPageIndex > 0 && !isLoading;

	private bool CanNavigateNext => currentPageIndex < maxPageIndex && !isLoading;

	private Task PreviousPageAsync() => NavigateToPageAsync(currentPageIndex - 1);

	private Task NextPageAsync() => NavigateToPageAsync(currentPageIndex + 1);

	private Task LastPageAsync() => NavigateToPageAsync(maxPageIndex);

	private int PaginationStartIndex
	{
		get
		{
			return currentPageIndex switch
			{
				0 or 1 or 2 => 0,
				_ => Math.Min(currentPageIndex - 2, maxPageIndex)
			};
		}
	}

	private int PaginationEndIndex => Math.Min(currentPageIndex + 3, maxPageIndex);

	private async Task NavigateToPageAsync(int pageIndex)
	{
		if (pageIndex == currentPageIndex)
			return;

		if (pageIndex < 0)
			pageIndex = 0;
		if (pageIndex > maxPageIndex)
			pageIndex = maxPageIndex;

		currentPageIndex = pageIndex;
		await ReloadData();
	}
}
